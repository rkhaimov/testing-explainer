# The goal of testing
 The state of unit testing
 The goal of unit testing
 Consequences of having a bad test suite
 Using coverage metrics to measure test
suite quality
 Attributes of a successful test suite

# What is a unit test
 What a unit test is
 The differences between shared, private,
and volatile dependencies
 The two schools of unit testing: classical
and London
 The differences between unit, integration,
and end-to-end tests

# The anatomy of a unit test
 The structure of a unit test
 Unit test naming best practices
 Working with parameterized tests
 Working with fluent assertions

# The four pillars of a good unit test
 Exploring dichotomies between aspects of a
good unit test
 Defining an ideal test
 Understanding the Test Pyramid
 Using black-box and white-box testing

# Mocks and test fragility
 Differentiating mocks from stubs
 Defining observable behavior and implementation details
 Understanding the relationship between mocks and test fragility
 Using mocks without compromising resistance to refactoring

# Styles of unit testing
 Comparing styles of unit testing
 The relationship between functional and hexagonal architectures
 Transitioning to output-based testing

# Refactoring toward valuable unit tests
 Recognizing the four types of code
 Understanding the Humble Object pattern
 Writing valuable tests

# Why integration testing
 Understanding the role of integration testing
 Diving deeper into the Test Pyramid concept
 Writing valuable integration tests

# Mocking best practices
 Maximizing the value of mocks
 Replacing mocks with spies
 Mocking best practices

# Testing the database ?

# Unit testing anti-patterns
 Unit testing private methods
 Exposing private state to enable unit testing
 Leaking domain knowledge to tests
 Mocking concrete classes
